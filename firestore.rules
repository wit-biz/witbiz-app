/**
 * @fileOverview
 * This ruleset enforces a strict user-ownership model for Leads, Contacts, and Tasks,
 * ensuring that each user can only access data associated with their own user ID.
 *
 * Data Structure:
 * All data is nested under /users/{userId}, with Leads, Contacts, and Tasks stored in
 * subcollections of each user's document. This hierarchical structure simplifies
 * authorization and improves query performance.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - All write operations require the user to be authenticated and the owner of the
 *   resource being modified.
 * - Read operations are restricted to the owner of the data.
 * - Flexible data shapes: The rules do not enforce the exact schema of the data being written,
 *   allowing for rapid iteration and changes to the data model.
 *
 * Denormalization for Authorization:
 * The user-ownership model avoids the need for costly `get()` calls by relying on the
 * path-based structure. The userId is already encoded in the path, so we can easily
 * validate ownership using the `request.auth.uid`.
 *
 * Structural Segregation:
 * The data is already segregated by user ID, with each user having their own subcollections
 * for Leads, Contacts, and Tasks. This eliminates the need for boolean flags or complex
 * queries to filter data based on ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // =====================================
    // üß© BLOQUE GLOBAL DE CONDICIONES
    // =====================================
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // =====================================
    // üë§ BLOQUE DE USUARIOS PRINCIPALES
    // =====================================
    /**
     * @description Controls access to user profile documents. Only the authenticated user can read or write their own profile.
     * @path /users/{userId}
     * @allow (read, write) if request.auth.uid == userId
     * @deny (read, write) if request.auth.uid != userId
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      allow get, list: if false; // No listing of users.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);

      // =====================================
      // üìö SUBCOLECCIONES DEL USUARIO
      // =====================================
      /**
       * @description Controls access to subcollections within a user's document (leads, contacts, tasks). Only the owner can read, write, or delete their own documents in these subcollections.
       * @path /users/{userId}/{subcollection}/{docId}
       * @allow (get, list, create, update, delete) if request.auth.uid == userId
       * @deny (get, list, create, update, delete) if request.auth.uid != userId
       * @principle Restricts access to a user's own data tree.
       */
      match /{subcollection}/{docId} {
        // --- LECTURA SEGURA (get y list) ---
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);

        // --- CREACI√ìN DE DOCUMENTOS ---
        allow create: if isOwner(userId);

        // --- ACTUALIZACI√ìN ---
        allow update: if isExistingOwner(userId);

        // --- ELIMINACI√ìN ---
        allow delete: if isExistingOwner(userId);

        // =====================================
        // ü™∂ SUBCOLECCIONES ANIDADAS (profundidad variable)
        // =====================================
        /**
         * @description Controls access to nested subcollections within a user's data tree. Only the owner can read or write data in these nested subcollections.
         * @path /users/{userId}/{subcollection}/{docId}/{nested=**}
         * @allow (read, write) if request.auth.uid == userId
         * @deny (read, write) if request.auth.uid != userId
         * @principle Restricts access to a user's own data tree (recursive).
         */
        match /{nested=**} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId);
          allow update: if isExistingOwner(userId);
          allow delete: if isExistingOwner(userId);
        }
      }

      /**
       * @description Controls access to leads within a user's document. Only the owner can read, write, or delete their own leads.
       * @path /users/{userId}/leads/{leadId}
       * @allow (get, list, create, update, delete) if request.auth.uid == userId
       * @deny (get, list, create, update, delete) if request.auth.uid != userId
       * @principle Restricts access to a user's own leads.
       */
      match /leads/{leadId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId);
          allow update: if isExistingOwner(userId);
          allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Controls access to contacts within a user's document. Only the owner can read, write, or delete their own contacts.
       * @path /users/{userId}/contacts/{contactId}
       * @allow (get, list, create, update, delete) if request.auth.uid == userId
       * @deny (get, list, create, update, delete) if request.auth.uid != userId
       * @principle Restricts access to a user's own contacts.
       */
      match /contacts/{contactId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId);
          allow update: if isExistingOwner(userId);
          allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Controls access to tasks within a user's document. Only the owner can read, write, or delete their own tasks.
       * @path /users/{userId}/tasks/{taskId}
       * @allow (get, list, create, update, delete) if request.auth.uid == userId
       * @deny (get, list, create, update, delete) if request.auth.uid != userId
       * @principle Restricts access to a user's own tasks.
       */
      match /tasks/{taskId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId);
          allow update: if isExistingOwner(userId);
          allow delete: if isExistingOwner(userId);
      }
    }

    // =====================================
    // ‚öôÔ∏è BLOQUE DE CONFIGURACI√ìN GENERAL
    // =====================================
    /**
     * @description Allows public read access to configuration documents.  No write access is allowed.
     * @path /config/{docId}
     * @allow (get, list) if true
     * @deny (create, update, delete) always
     * @principle Public read access for configuration.
     */
    match /config/{docId} {
      // Solo lectura global (si aplica a configuraciones p√∫blicas)
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    // =====================================
    // üö´ BLOQUE POR DEFECTO (DENEGAR TODO)
    // =====================================
    /**
     * @description Catches all unmatched paths and denies all read and write access.
     * @path /{document=**}
     * @deny (read, write) always
     * @principle Default deny for unmatched paths.
     */
    match /{document=**} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}