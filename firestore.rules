/**
 * @fileoverview Firestore Security Rules for WitCRM application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model, where each user has exclusive access to their leads, contacts, and tasks.
 *
 * Data Structure:
 * All data is nested under /users/{userId}, ensuring that all leads, contacts, and tasks are associated with a specific user.
 *  - /users/{userId}/leads/{leadId}
 *  - /users/{userId}/contacts/{contactId}
 *  - /users/{userId}/tasks/{taskId}
 *
 * Key Security Decisions:
 * - Users can only access their own data, preventing unauthorized access to other users' information.
 * - Data access is controlled via path-based rules.
 *
 * Denormalization for Authorization:
 * - The `assignedTo` field in the Task entity should match the `userId` in the path `/users/{userId}/tasks/{taskId}`. This simplifies ownership checks and avoids additional reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces access control for leads, ensuring only the owner can manage them.
     * @path /users/{userId}/leads/{leadId}
     * @allow (create) - Authenticated user with UID 'user123' can create a lead under /users/user123/leads/lead456.
     * @allow (get) - Authenticated user with UID 'user123' can read a lead under /users/user123/leads/lead456.
     * @allow (update) - Authenticated user with UID 'user123' can update a lead under /users/user123/leads/lead456.
     * @allow (delete) - Authenticated user with UID 'user123' can delete a lead under /users/user123/leads/lead456.
     * @allow (list) - Authenticated user with UID 'user123' can list leads under /users/user123/leads.
     * @deny (create) - Authenticated user with UID 'user456' cannot create a lead under /users/user123/leads/lead789.
     * @deny (get) - Authenticated user with UID 'user456' cannot read a lead under /users/user123/leads/lead789.
     * @deny (update) - Authenticated user with UID 'user456' cannot update a lead under /users/user123/leads/lead789.
     * @deny (delete) - Authenticated user with UID 'user456' cannot delete a lead under /users/user123/leads/lead789.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree, validates relational integrity between documents.
     */
    match /users/{userId}/leads/{leadId} {
      // Allow reads (get, list) only if the user is signed in and is the owner of the lead.
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      // Allow create only if the user is signed in and the userId matches the authenticated user's UID. Also, enforce that the leadId in the path matches the id in the request data.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == leadId;

      // Allow update only if the user is signed in, is the owner of the lead, and the document exists. Also, enforce immutability of the id field.
      allow update: if isSignedIn() && isExistingOwner(userId) && resource.data.id == request.resource.data.id;

      // Allow delete only if the user is signed in, is the owner of the lead, and the document exists.
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for contacts, ensuring only the owner can manage them.
     * @path /users/{userId}/contacts/{contactId}
     * @allow (create) - Authenticated user with UID 'user123' can create a contact under /users/user123/contacts/contact456.
     * @allow (get) - Authenticated user with UID 'user123' can read a contact under /users/user123/contacts/contact456.
     * @allow (update) - Authenticated user with UID 'user123' can update a contact under /users/user123/contacts/contact456.
     * @allow (delete) - Authenticated user with UID 'user123' can delete a contact under /users/user123/contacts/contact456.
     * @allow (list) - Authenticated user with UID 'user123' can list contacts under /users/user123/contacts.
     * @deny (create) - Authenticated user with UID 'user456' cannot create a contact under /users/user123/contacts/contact789.
     * @deny (get) - Authenticated user with UID 'user456' cannot read a contact under /users/user123/contacts/contact789.
     * @deny (update) - Authenticated user with UID 'user456' cannot update a contact under /users/user123/contacts/contact789.
     * @deny (delete) - Authenticated user with UID 'user456' cannot delete a contact under /users/user123/contacts/contact789.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree, validates relational integrity between documents.
     */
    match /users/{userId}/contacts/{contactId} {
      // Allow reads (get, list) only if the user is signed in and is the owner of the contact.
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      // Allow create only if the user is signed in and the userId matches the authenticated user's UID. Also, enforce that the contactId in the path matches the id in the request data.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == contactId;

      // Allow update only if the user is signed in, is the owner of the contact, and the document exists. Also, enforce immutability of the id field.
      allow update: if isSignedIn() && isExistingOwner(userId) && resource.data.id == request.resource.data.id;

      // Allow delete only if the user is signed in, is the owner of the contact, and the document exists.
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for tasks, ensuring only the assigned user can manage them.
     * @path /users/{userId}/tasks/{taskId}
     * @allow (create) - Authenticated user with UID 'user123' can create a task under /users/user123/tasks/task456.
     * @allow (get) - Authenticated user with UID 'user123' can read a task under /users/user123/tasks/task456.
     * @allow (update) - Authenticated user with UID 'user123' can update a task under /users/user123/tasks/task456.
     * @allow (delete) - Authenticated user with UID 'user123' can delete a task under /users/user123/tasks/task456.
     * @allow (list) - Authenticated user with UID 'user123' can list tasks under /users/user123/tasks.
     * @deny (create) - Authenticated user with UID 'user456' cannot create a task under /users/user123/tasks/task789.
     * @deny (get) - Authenticated user with UID 'user456' cannot read a task under /users/user123/tasks/task789.
     * @deny (update) - Authenticated user with UID 'user456' cannot update a task under /users/user123/tasks/task789.
     * @deny (delete) - Authenticated user with UID 'user456' cannot delete a task under /users/user123/tasks/task789.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree, validates relational integrity between documents.
     */
    match /users/{userId}/tasks/{taskId} {
      // Allow reads (get, list) only if the user is signed in and is the owner of the task.
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      // Allow create only if the user is signed in and the userId matches the authenticated user's UID. Also, enforce that the taskId in the path matches the id in the request data.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == taskId;

      // Allow update only if the user is signed in, is the owner of the task, and the document exists. Also, enforce immutability of the id field.
      allow update: if isSignedIn() && isExistingOwner(userId) && resource.data.id == request.resource.data.id;

      // Allow delete only if the user is signed in, is the owner of the task, and the document exists.
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }
  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
    return isSignedIn() && isOwner(userId) && resource != null;
  }
}